diff --git a/Makefile b/Makefile
index 328f9c6..4885eef 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_part2Tests\
+	$U/_Csemaphore\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/console.c b/kernel/console.c
index 23a2d35..a5218d0 100644
--- a/kernel/console.c
+++ b/kernel/console.c
@@ -89,7 +89,7 @@ consoleread(int user_dst, uint64 dst, int n)
     // wait until interrupt handler has put some
     // input into cons.buffer.
     while(cons.r == cons.w){
-      if(myproc()->killed){
+      if(mythread()->killed){
         release(&cons.lock);
         return -1;
       }
diff --git a/kernel/defs.h b/kernel/defs.h
index 41098f4..406830f 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -89,10 +89,22 @@ int             growproc(int);
 void            proc_mapstacks(pagetable_t);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
-int             kill(int);
+int             kill(int, int);
 struct cpu*     mycpu(void);
 struct cpu*     getmycpu(void);
 struct proc*    myproc();
+uint            sigprocmask(uint);
+int             sigaction(int, uint64 act, uint64 oldact);
+void            sigret(void);
+struct thread*  mythread();
+int             kthread_create(uint64, uint64);
+int             kthread_id();
+void            kthread_exit(int);
+int             kthread_join(int, int*);
+int             bsem_alloc();
+void            bsem_free(int);
+void            bsem_down(int);
+void            bsem_up(int);
 void            procinit(void);
 void            scheduler(void) __attribute__((noreturn));
 void            sched(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 0e8762f..4b78c1b 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -21,6 +21,21 @@ exec(char *path, char **argv)
   pagetable_t pagetable = 0, oldpagetable;
   struct proc *p = myproc();
 
+  struct thread *curr_t = mythread();
+  struct thread *t;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++) {
+    acquire(&t->lock);
+    if(t != curr_t && t->state != TUNUSED){
+      t->killed = 1;
+      if(t->state == TSLEEPING)
+        t->state = TRUNNABLE;
+      release(&t->lock);
+      kthread_join(t->tid, 0);
+    } else {
+      release(&t->lock);
+    }
+  }
+
   begin_op();
 
   if((ip = namei(path)) == 0){
@@ -100,7 +115,7 @@ exec(char *path, char **argv)
   // arguments to user main(argc, argv)
   // argc is returned via the system call return
   // value, which goes in a0.
-  p->trapframe->a1 = sp;
+  curr_t->trapframe->a1 = sp;
 
   // Save program name for debugging.
   for(last=s=path; *s; s++)
@@ -112,10 +127,18 @@ exec(char *path, char **argv)
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
   p->sz = sz;
-  p->trapframe->epc = elf.entry;  // initial program counter = main
-  p->trapframe->sp = sp; // initial stack pointer
+  curr_t->trapframe->epc = elf.entry;  // initial program counter = main
+  curr_t->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  // When using exec, we returns all customs to DEFAULT. 
+  for(int i = 0; i < 32; i++) {
+    // SIG_DFL and SIG_IGN should be kept
+    if(p->signalHandlers[i] != (void*)SIG_DFL && p->signalHandlers[i] != (void*)SIG_IGN)
+        p->signalHandlers[i] = (void*)SIG_DFL;
+    p->handlersMasks[i] = 0;
+  }
+  p->pendingSignals = 0;
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/memlayout.h b/kernel/memlayout.h
index 776f98c..26c02ea 100644
--- a/kernel/memlayout.h
+++ b/kernel/memlayout.h
@@ -64,4 +64,4 @@
 //   ...
 //   TRAPFRAME (p->trapframe, used by the trampoline)
 //   TRAMPOLINE (the same page as in the kernel)
-#define TRAPFRAME (TRAMPOLINE - PGSIZE)
+#define TRAPFRAME(i) ((TRAMPOLINE - PGSIZE) + (i * sizeof(struct trapframe)))
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..0b532a9 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -9,5 +9,12 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
+#define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+
+#define SIG_DFL      0 
+#define SIG_IGN      1 
+#define SIGKILL      9
+#define SIGSTOP      17
+#define SIGCONT      19
+#define MAX_STACK_SIZE 4000
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..1ea5b8c 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -6,6 +6,11 @@
 #include "proc.h"
 #include "defs.h"
 
+#define MAX_BSEM 128
+struct binary_semaphore semaphores[MAX_BSEM];
+extern void* sigret_start(void);
+extern void* sigret_end(void);
+
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
@@ -13,10 +18,13 @@ struct proc proc[NPROC];
 struct proc *initproc;
 
 int nextpid = 1;
+int nexttid = 1;
 struct spinlock pid_lock;
+struct spinlock tid_lock;
 
 extern void forkret(void);
 static void freeproc(struct proc *p);
+static void freethread(struct thread *t);
 
 extern char trampoline[]; // trampoline.S
 
@@ -47,13 +55,19 @@ void
 procinit(void)
 {
   struct proc *p;
-  
+  struct thread *t;
+  struct binary_semaphore* b;
+  initlock(&tid_lock, "nexttid");
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
-      initlock(&p->lock, "proc");
-      p->kstack = KSTACK((int) (p - proc));
+    initlock(&p->lock, "proc");
+    for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+      initlock(&t->lock, "thread");
+    }
   }
+  for(b = semaphores; b < &semaphores[MAX_BSEM]; b++)
+    initlock(&b->lock, "binary_semaphore");
 }
 
 // Must be called with interrupts disabled,
@@ -85,6 +99,15 @@ myproc(void) {
   return p;
 }
 
+struct thread*
+mythread(void) {
+  push_off();
+  struct cpu *c = mycpu();
+  struct thread *t = c->t;
+  pop_off();
+  return t;
+}
+
 int
 allocpid() {
   int pid;
@@ -97,6 +120,64 @@ allocpid() {
   return pid;
 }
 
+int alloctid()
+{
+  int tid;
+
+  acquire(&tid_lock);
+  tid = nexttid;
+  nexttid = nexttid + 1;
+  release(&tid_lock);
+
+  return tid;
+}
+
+static struct thread*
+allocthread(struct proc *p)
+{
+  struct thread *t;
+  struct thread *curr_t = mythread();                  
+  int index = 0;
+  for(t = p->threads; &p->threads[NTHREAD]; t++) {
+    if(t != curr_t) {
+      acquire(&t->lock);
+      if(t->state == TUNUSED) {
+        goto found;
+      } else {
+        release(&t->lock);
+      } 
+    }
+    index++;
+  }
+  return 0;
+
+found:
+  t->index = index;
+  t->tid = alloctid();
+  t->state = TUSED;
+  t->killed = 0;
+  t->parent = p;
+  t->trapframe = &p->trapframes[index];
+
+  if((t->backupFrame = (struct trapframe *)kalloc()) == 0) {
+    freethread(t);
+    release(&t->lock);
+    return 0;
+  }
+
+  if((t->kstack = (uint64)kalloc()) == 0){
+    freethread(t);
+    release(&t->lock);
+    return 0;
+  }
+
+  memset(&t->context, 0, sizeof(t->context));
+  t->context.ra = (uint64)forkret;
+  t->context.sp = t->kstack + PGSIZE;
+
+  return t;
+}
+
 // Look in the process table for an UNUSED proc.
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
@@ -121,7 +202,7 @@ found:
   p->state = USED;
 
   // Allocate a trapframe page.
-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+  if((p->trapframes = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
     release(&p->lock);
     return 0;
@@ -135,12 +216,21 @@ found:
     return 0;
   }
 
+  for(int i = 0; i < 32; i++)
+    p->signalHandlers[i] = (void*)SIG_DFL;
+  
+  struct thread *t = allocthread(p);
+  if(t == 0){
+    release(&t->lock);          
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  release(&t->lock);
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
-  memset(&p->context, 0, sizeof(p->context));
-  p->context.ra = (uint64)forkret;
-  p->context.sp = p->kstack + PGSIZE;
-
   return p;
 }
 
@@ -150,9 +240,9 @@ found:
 static void
 freeproc(struct proc *p)
 {
-  if(p->trapframe)
-    kfree((void*)p->trapframe);
-  p->trapframe = 0;
+  if(p->trapframes)
+    kfree((void*)p->trapframes);
+  p->trapframes = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
@@ -160,10 +250,42 @@ freeproc(struct proc *p)
   p->pid = 0;
   p->parent = 0;
   p->name[0] = 0;
-  p->chan = 0;
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+  p->pendingSignals = 0;
+  p->sigmask = 0;
+
+  for(int i = 0; i < 32; i++){
+    p->signalHandlers[i] = (void*)SIG_DFL;
+    p->handlersMasks[i] = 0;
+  }
+
+  p->isHandling = 0;
+  p->previousMask = 0;
+
+  struct thread *t;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++)
+    freethread(t);
+}
+
+static void
+freethread(struct thread *t)
+{
+  if(t->backupFrame)
+    kfree((void*)t->backupFrame);
+  t->backupFrame = 0;
+  if(t->kstack)
+    kfree((void*)t->kstack);
+  t->kstack = 0;
+  t->trapframe = 0;
+  t->chan = 0;
+  t->index = 0;
+  t->xstate = 0;
+  t->tid = 0;
+  t->parent = 0;
+  t->killed = 0;
+  t->state = TUNUSED;
 }
 
 // Create a user page table for a given process,
@@ -189,8 +311,8 @@ proc_pagetable(struct proc *p)
   }
 
   // map the trapframe just below TRAMPOLINE, for trampoline.S.
-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+  if(mappages(pagetable, TRAPFRAME(0), PGSIZE,
+              (uint64)(p->trapframes), PTE_R | PTE_W) < 0){
     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
     uvmfree(pagetable, 0);
     return 0;
@@ -205,7 +327,7 @@ void
 proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
-  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmunmap(pagetable, TRAPFRAME(0), 1, 0);
   uvmfree(pagetable, sz);
 }
 
@@ -236,15 +358,15 @@ userinit(void)
   p->sz = PGSIZE;
 
   // prepare for the very first "return" from kernel to user.
-  p->trapframe->epc = 0;      // user program counter
-  p->trapframe->sp = PGSIZE;  // user stack pointer
+  p->trapframes->epc = 0;      // user program counter
+  p->trapframes->sp = PGSIZE;  // user stack pointer
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  p->state = RUNNABLE;
+  p->threads[0].state = TRUNNABLE;
 
-  release(&p->lock);
+  release(&p->lock); 
 }
 
 // Grow or shrink user memory by n bytes.
@@ -254,16 +376,18 @@ growproc(int n)
 {
   uint sz;
   struct proc *p = myproc();
-
+  acquire(&p->lock);
   sz = p->sz;
   if(n > 0){
     if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
+      release(&p->lock);
       return -1;
     }
   } else if(n < 0){
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
   p->sz = sz;
+  release(&p->lock);
   return 0;
 }
 
@@ -274,13 +398,15 @@ fork(void)
 {
   int i, pid;
   struct proc *np;
+  struct thread *nt;
   struct proc *p = myproc();
+  struct thread *curr_t = mythread();
 
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
   }
-
+  
   // Copy user memory from parent to child.
   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
     freeproc(np);
@@ -288,12 +414,11 @@ fork(void)
     return -1;
   }
   np->sz = p->sz;
-
-  // copy saved user registers.
-  *(np->trapframe) = *(p->trapframe);
+  nt = &np->threads[0];
+  *nt->trapframe = *curr_t->trapframe;
 
   // Cause fork to return 0 in the child.
-  np->trapframe->a0 = 0;
+  nt->trapframe->a0 = 0;
 
   // increment reference counts on open file descriptors.
   for(i = 0; i < NOFILE; i++)
@@ -304,6 +429,13 @@ fork(void)
   safestrcpy(np->name, p->name, sizeof(p->name));
 
   pid = np->pid;
+  // When fork is used, parent's signal mask and signal handlers will be inherited but not pending signals
+  np->sigmask = p->sigmask;
+  for(int i = 0; i < 32; i++){
+    np->signalHandlers[i] = p->signalHandlers[i];
+    np->handlersMasks[i] = p->handlersMasks[i];
+  }
+  np->pendingSignals = 0;
 
   release(&np->lock);
 
@@ -311,9 +443,9 @@ fork(void)
   np->parent = p;
   release(&wait_lock);
 
-  acquire(&np->lock);
-  np->state = RUNNABLE;
-  release(&np->lock);
+  acquire(&nt->lock);
+  nt->state = TRUNNABLE;
+  release(&nt->lock);
 
   return pid;
 }
@@ -340,6 +472,7 @@ void
 exit(int status)
 {
   struct proc *p = myproc();
+  struct thread *curr_t = mythread();
 
   if(p == initproc)
     panic("init exiting");
@@ -371,6 +504,22 @@ exit(int status)
   p->xstate = status;
   p->state = ZOMBIE;
 
+  struct thread *t;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+    if(t != curr_t && t->state != TUNUSED){
+      acquire(&t->lock);
+      t->killed = 1;
+      if(t->state == TSLEEPING)
+        t->state = TRUNNABLE;
+      release(&t->lock);
+      // waiting for thread to be killed
+      kthread_join(t->tid, 0);
+    }
+  }
+  release(&p->lock);
+  acquire(&curr_t->lock);
+  curr_t->state = TZOMBIE;
+
   release(&wait_lock);
 
   // Jump into the scheduler, never to return.
@@ -438,28 +587,30 @@ void
 scheduler(void)
 {
   struct proc *p;
+  struct thread *t;
   struct cpu *c = mycpu();
   
   c->proc = 0;
+  c->t = 0;
   for(;;){
     // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
     for(p = proc; p < &proc[NPROC]; p++) {
-      acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
+      if(p->state == USED){
+        for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+          acquire(&t->lock);
+          if(t->state == TRUNNABLE){
+            c->proc = p;
+            c->t = t;
+            t->state = TRUNNING;
+            swtch(&c->context, &t->context);
+            c->proc = 0;
+            c->t = 0;
+          }
+          release(&t->lock);
+        }
       }
-      release(&p->lock);
     }
   }
 }
@@ -475,19 +626,17 @@ void
 sched(void)
 {
   int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&p->lock))
+  struct thread *t = mythread();
+  if(!holding(&t->lock)) 
     panic("sched p->lock");
   if(mycpu()->noff != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if(t->state == TRUNNING)
     panic("sched running");
   if(intr_get())
     panic("sched interruptible");
-
   intena = mycpu()->intena;
-  swtch(&p->context, &mycpu()->context);
+  swtch(&t->context, &mycpu()->context);
   mycpu()->intena = intena;
 }
 
@@ -495,11 +644,11 @@ sched(void)
 void
 yield(void)
 {
-  struct proc *p = myproc();
-  acquire(&p->lock);
-  p->state = RUNNABLE;
+  struct thread *t = mythread();
+  acquire(&t->lock);
+  t->state = TRUNNABLE;
   sched();
-  release(&p->lock);
+  release(&t->lock);
 }
 
 // A fork child's very first scheduling by scheduler()
@@ -510,7 +659,7 @@ forkret(void)
   static int first = 1;
 
   // Still holding p->lock from scheduler.
-  release(&myproc()->lock);
+  release(&mythread()->lock);
 
   if (first) {
     // File system initialization must be run in the context of a
@@ -528,7 +677,7 @@ forkret(void)
 void
 sleep(void *chan, struct spinlock *lk)
 {
-  struct proc *p = myproc();
+  struct thread *t = mythread();
   
   // Must acquire p->lock in order to
   // change p->state and then call sched.
@@ -537,20 +686,20 @@ sleep(void *chan, struct spinlock *lk)
   // (wakeup locks p->lock),
   // so it's okay to release lk.
 
-  acquire(&p->lock);  //DOC: sleeplock1
+  acquire(&t->lock);  //DOC: sleeplock1
   release(lk);
 
   // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
+  t->chan = chan;
+  t->state = TSLEEPING;
 
   sched();
 
   // Tidy up.
-  p->chan = 0;
+  t->chan = 0;
 
   // Reacquire original lock.
-  release(&p->lock);
+  release(&t->lock);
   acquire(lk);
 }
 
@@ -560,14 +709,18 @@ void
 wakeup(void *chan)
 {
   struct proc *p;
+  struct thread *t;
+  struct thread *curr_t = mythread();
 
   for(p = proc; p < &proc[NPROC]; p++) {
-    if(p != myproc()){
-      acquire(&p->lock);
-      if(p->state == SLEEPING && p->chan == chan) {
-        p->state = RUNNABLE;
+    for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+      if(t != curr_t){ 
+        acquire(&t->lock);
+        if(t->state == TSLEEPING && t->chan == chan) {
+          t->state = TRUNNABLE;
+        }
+        release(&t->lock);
       }
-      release(&p->lock);
     }
   }
 }
@@ -576,18 +729,17 @@ wakeup(void *chan)
 // The victim won't exit until it tries to return
 // to user space (see usertrap() in trap.c).
 int
-kill(int pid)
+kill(int pid, int signum)
 {
   struct proc *p;
-
   for(p = proc; p < &proc[NPROC]; p++){
     acquire(&p->lock);
     if(p->pid == pid){
-      p->killed = 1;
-      if(p->state == SLEEPING){
-        // Wake process from sleep().
-        p->state = RUNNABLE;
+      if(p->state != USED){
+        release(&p->lock);
+        return -1;
       }
+      p->pendingSignals = (p->pendingSignals | (1 << signum));
       release(&p->lock);
       return 0;
     }
@@ -634,9 +786,6 @@ procdump(void)
 {
   static char *states[] = {
   [UNUSED]    "unused",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
   [ZOMBIE]    "zombie"
   };
   struct proc *p;
@@ -654,3 +803,319 @@ procdump(void)
     printf("\n");
   }
 }
+
+uint
+sigprocmask(uint sigmask)
+{
+  if(sigmask != SIGKILL && sigmask != SIGSTOP){
+    struct proc *p = myproc();
+    acquire(&p->lock);
+    uint oldMask = p->sigmask;
+    p->sigmask = sigmask;
+    release(&p->lock);
+    return oldMask;
+  } else{
+    return -1;
+  }
+}
+
+int
+updateHandler(struct proc *p, uint64 act, int signum)
+{
+  struct sigaction tmp;
+  int isOk = 1;
+  if(act){
+    if((copyin(p->pagetable, (char*)&tmp, act, sizeof(struct sigaction)) >= 0)){
+      if((((1 << SIGKILL) & tmp.sigmask) != 0) || (((1 << SIGSTOP) & tmp.sigmask) != 0)) {
+        release(&p->lock);
+        isOk = 0;
+      } else {
+        p->signalHandlers[signum] = tmp.sa_handler;
+        p->handlersMasks[signum] = tmp.sigmask;
+      }
+    }
+  }
+  return isOk;
+}
+
+int
+sigaction(int signum, uint64 act, uint64 oldact)
+{
+  struct proc *p = myproc();
+  // We shouldn't change the default handler for SIGDFL and SIGKILL
+  if(signum < 0 || signum > 31 || signum == SIGKILL || signum == SIGSTOP)
+    return -1;
+  acquire(&p->lock);
+  // If oldcat is non-NULL then save the previous action in oldact
+  if(oldact){
+    copyout(p->pagetable, oldact, (char*)&p->signalHandlers[signum], sizeof(p->signalHandlers[signum]));  // copy the handler
+    copyout(p->pagetable, oldact + sizeof(p->signalHandlers[signum]), (char*)&p->handlersMasks[signum], sizeof(uint));  // copy the specific sigmask
+  }
+  if(!updateHandler(p, act, signum))
+    return -1;
+  release(&p->lock);
+  return 0;
+}
+
+// Restoring the process original workflow
+void
+sigret(void)
+{
+  struct proc *p = myproc();
+  struct thread *t = mythread();
+  acquire(&p->lock);
+  acquire(&t->lock);
+  memmove(t->trapframe, t->backupFrame, sizeof(struct trapframe));
+  p->sigmask = p->previousMask;
+  p->isHandling = 0;
+  release(&t->lock);
+  release(&p->lock);
+}
+
+void
+sigkill()
+{
+  struct proc *p = myproc();
+  struct thread *t;
+  p->killed = 1;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++) {
+    acquire(&t->lock);
+    if(t->state == TSLEEPING){
+      t->state = TRUNNABLE;
+    }
+    release(&t->lock);
+  }  
+}
+
+void
+sigcont()
+{
+  struct proc *p = myproc();
+  if (((1 << SIGSTOP) & p->pendingSignals) == 0)
+    p->pendingSignals = p->pendingSignals & ~(1 << SIGCONT);
+}
+
+void
+sigstop()
+{
+  struct proc *p = myproc();
+  while(1){
+    if (!holding(&p->lock))
+      acquire(&p->lock);
+    if (!(p->pendingSignals & (1 << SIGCONT))){
+      release(&p->lock);
+      yield();
+    } else {
+      break;
+    }
+  }
+  p->pendingSignals = p->pendingSignals & ~(1 << SIGSTOP);
+  p->pendingSignals = p->pendingSignals & ~(1 << SIGCONT);
+}
+
+void
+checkAndExecute(struct proc *p, int i, uint currSig)
+{
+  switch(i){
+    case SIGKILL:
+      sigkill();
+      p->pendingSignals = p->pendingSignals & ~currSig;
+      break;
+    case SIGSTOP:
+      sigstop();
+      break;
+    case SIGCONT:
+      sigcont();
+      break;
+    default:
+      sigkill();
+      p->pendingSignals = p->pendingSignals & ~currSig;
+      break;
+  }
+}
+
+void 
+notSIG_DFL(struct proc *p, int i, uint currSig)
+{
+  struct thread *t = mythread();
+  p->previousMask = p->sigmask;
+  p->sigmask = p->handlersMasks[i];
+  p->isHandling = 1;
+  memmove(t->backupFrame, t->trapframe, sizeof(struct trapframe));
+  uint sigret_size = sigret_end - sigret_start;
+  t->trapframe->sp -= sigret_size;
+  copyout(p->pagetable, (uint64)t->trapframe->sp, (char*)&sigret_start, sigret_size);
+  t->trapframe->a0 = i;
+  t->trapframe->ra = t->trapframe->sp;
+  p->pendingSignals = p->pendingSignals & ~currSig;
+  t->trapframe->epc = (uint64)p->signalHandlers[i];
+}
+
+void
+handleSignals()
+{
+  struct proc *p = myproc();
+  acquire(&p->lock);
+  if (p->isHandling){ 
+    release(&p->lock);
+    return;
+  }
+  for(int i = 0; i < 32; i++){
+    uint currSig = 1 << i;
+    if((currSig & p->pendingSignals) && !(currSig & p->sigmask)){
+      if (p->signalHandlers[i] == (void*)SIG_IGN) {
+        p->pendingSignals = p->pendingSignals & ~currSig;
+        continue;
+      }
+      if (p->signalHandlers[i] == (void*)SIG_DFL){
+        checkAndExecute(p, i, currSig);
+      }
+      else { 
+        notSIG_DFL(p, i, currSig);
+      }
+    }
+  }
+  release(&p->lock);
+}
+
+int
+kthread_create(uint64 start_func, uint64 stack)
+{
+  int tid;
+  struct proc *p = myproc();
+  struct thread *t = mythread();
+  struct thread *nt = nt = allocthread(p);
+
+  if(nt != 0) {
+    tid = nt->tid;
+    nt->state = TRUNNABLE;
+    *nt->trapframe = *t->trapframe;
+    nt->trapframe->epc = (uint64)start_func;
+    nt->trapframe->sp = (uint64)(stack + MAX_STACK_SIZE - 16);
+    release(&nt->lock);
+    return tid;
+  }
+  return -1;
+}
+
+int
+kthread_id()
+{
+  struct thread *t = mythread();
+  if(t == 0)
+    return -1;
+  return t->tid;
+}
+
+void kthread_exit(int status)
+{
+  struct proc *p = myproc();
+  struct thread *curr_t = mythread();
+  struct thread *t;
+
+  acquire(&p->lock);
+  int numOfThreads = 0;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+    acquire(&t->lock);
+    if(t != curr_t && t->state != TUNUSED && t->state != TZOMBIE)
+      numOfThreads++;
+    release(&t->lock);
+  }
+  if (numOfThreads == 0) {
+    release(&p->lock);
+    exit(status);
+  }
+
+  acquire(&curr_t->lock);
+  curr_t->xstate = status;
+  curr_t->state = TZOMBIE;
+
+  release(&p->lock);
+  
+  wakeup(curr_t);
+  
+  sched();
+}
+
+int
+kthread_join(int thread_id, int *status)
+{
+  struct thread *toJoinThread;
+  struct proc *p = myproc();
+  struct thread *t;
+
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++) {
+    acquire(&t->lock);
+    if(thread_id == t->tid) {
+      toJoinThread = t;
+      goto found;
+    }
+    release(&t->lock);
+  }
+
+  return -1;
+
+  found:
+    while (toJoinThread->state != TZOMBIE && toJoinThread->state != TUNUSED)  // waiting for the thread to finish its running
+      sleep(toJoinThread, &toJoinThread->lock);
+
+    if(toJoinThread->state == TZOMBIE){ // which means the thread finished his running
+      if(status != 0 && copyout(p->pagetable, (uint64)status, (char *)&toJoinThread->xstate, sizeof(toJoinThread->xstate)) < 0) {
+        release(&toJoinThread->lock);
+        return -1;
+      }
+      freethread(toJoinThread);
+    } 
+
+    release(&toJoinThread->lock);
+    return 0;
+}
+
+int bsem_alloc()
+{
+  int d;
+  int isOk = 0;
+  for(d = 0; d < MAX_BSEM && !isOk; d++){
+    acquire(&semaphores[d].lock);
+    if(!semaphores[d].isTaken){
+      isOk = 1;
+      break;
+    }
+    release(&semaphores[d].lock);
+  }
+  if(isOk){
+    semaphores[d].isTaken = 1;
+    semaphores[d].val = 1;    
+    release(&semaphores[d].lock);
+    return d;
+  }
+  return -1;
+}
+
+void bsem_free(int d)
+{
+  acquire(&semaphores[d].lock);
+  semaphores[d].isTaken = 0;
+  release(&semaphores[d].lock);
+}
+
+void bsem_down(int d)
+{
+  acquire(&semaphores[d].lock);
+  if(semaphores[d].isTaken) {
+    while(semaphores[d].val == 0)
+      sleep(&semaphores[d], &semaphores[d].lock);
+    semaphores[d].val = 0;
+  }
+  release(&semaphores[d].lock);
+}
+
+void bsem_up(int d)
+{
+  acquire(&semaphores[d].lock);
+  if(semaphores[d].isTaken) {
+    semaphores[d].val = 1;
+    wakeup(&semaphores[d]);
+  }
+  release(&semaphores[d].lock);
+}
\ No newline at end of file
diff --git a/kernel/proc.h b/kernel/proc.h
index 8e90008..3f09ad0 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -1,3 +1,5 @@
+#define NTHREAD 8
+
 // Saved registers for kernel context switches.
 struct context {
   uint64 ra;
@@ -24,6 +26,7 @@ struct cpu {
   struct context context;     // swtch() here to enter scheduler().
   int noff;                   // Depth of push_off() nesting.
   int intena;                 // Were interrupts enabled before push_off()?
+  struct thread *t;
 };
 
 extern struct cpu cpus[NCPU];
@@ -80,7 +83,23 @@ struct trapframe {
   /* 280 */ uint64 t6;
 };
 
-enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate { UNUSED, USED, ZOMBIE }; // There is no need to other STATES
+enum threadstate { TUNUSED, TUSED, TSLEEPING, TRUNNABLE, TRUNNING, TZOMBIE };
+
+struct thread {
+  struct spinlock lock;
+  enum threadstate state;
+  int killed;
+  int xstate;
+  int tid;
+  struct proc *parent;
+  void *chan;
+  int index;                    // TrapeFrame index
+  struct trapframe *trapframe;
+  struct trapframe *backupFrame;  // User trapframe backup
+  struct context context; 
+  uint64 kstack; 
+};
 
 // Per-process state
 struct proc {
@@ -88,7 +107,6 @@ struct proc {
 
   // p->lock must be held when using these:
   enum procstate state;        // Process state
-  void *chan;                  // If non-zero, sleeping on chan
   int killed;                  // If non-zero, have been killed
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
@@ -97,12 +115,32 @@ struct proc {
   struct proc *parent;         // Parent process
 
   // these are private to the process, so p->lock need not be held.
-  uint64 kstack;               // Virtual address of kernel stack
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
-  struct trapframe *trapframe; // data page for trampoline.S
-  struct context context;      // swtch() here to run process
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  struct thread threads[NTHREAD];
+  struct trapframe *trapframes;
+
+  uint pendingSignals;
+  uint sigmask;
+  void *signalHandlers[32];
+  uint handlersMasks[32];       // There are masks Foreach handler
+  int isHandling;               // In case the proc is currently handling a signal, so it just blocks handling other signals
+  uint previousMask;            // This is for holding the sigmask while executing a signalHandler
+};
+
+struct sigaction
+{
+  void (*sa_handler) (int);
+  uint sigmask;
 };
+void handleSignals();
+
+struct binary_semaphore {
+  int val;
+  int isTaken;
+  struct spinlock lock;
+};
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..d126d46 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -34,20 +34,20 @@ fetchstr(uint64 addr, char *buf, int max)
 static uint64
 argraw(int n)
 {
-  struct proc *p = myproc();
+  struct thread *t = mythread();
   switch (n) {
   case 0:
-    return p->trapframe->a0;
+    return t->trapframe->a0;
   case 1:
-    return p->trapframe->a1;
+    return t->trapframe->a1;
   case 2:
-    return p->trapframe->a2;
+    return t->trapframe->a2;
   case 3:
-    return p->trapframe->a3;
+    return t->trapframe->a3;
   case 4:
-    return p->trapframe->a4;
+    return t->trapframe->a4;
   case 5:
-    return p->trapframe->a5;
+    return t->trapframe->a5;
   }
   panic("argraw");
   return -1;
@@ -104,6 +104,17 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_sigprocmask(void);
+extern uint64 sys_sigaction(void);
+extern uint64 sys_sigret(void);
+extern uint64 sys_kthread_create(void);
+extern uint64 sys_kthread_id(void);
+extern uint64 sys_kthread_exit(void);
+extern uint64 sys_kthread_join(void);
+extern uint64 sys_bsem_alloc(void);
+extern uint64 sys_bsem_free(void);
+extern uint64 sys_bsem_down(void);
+extern uint64 sys_bsem_up(void);
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,20 +138,31 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_sigprocmask]   sys_sigprocmask,
+[SYS_sigaction]     sys_sigaction,
+[SYS_sigret]        sys_sigret,
+[SYS_kthread_create] sys_kthread_create,
+[SYS_kthread_id]     sys_kthread_id,
+[SYS_kthread_exit]   sys_kthread_exit,
+[SYS_kthread_join]   sys_kthread_join,
+[SYS_bsem_alloc]     sys_bsem_alloc,
+[SYS_bsem_free]      sys_bsem_free,
+[SYS_bsem_down]      sys_bsem_down,
+[SYS_bsem_up]        sys_bsem_up,
 };
 
 void
 syscall(void)
 {
   int num;
-  struct proc *p = myproc();
+  struct thread *t = mythread();
 
-  num = p->trapframe->a7;
+  num = t->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    p->trapframe->a0 = syscalls[num]();
+    t->trapframe->a0 = syscalls[num]();
   } else {
     printf("%d %s: unknown sys call %d\n",
-            p->pid, p->name, num);
-    p->trapframe->a0 = -1;
+            t->parent->pid, t->parent->name, num);
+    t->trapframe->a0 = -1;
   }
 }
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..b540e38 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,14 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigprocmask 22
+#define SYS_sigaction   23
+#define SYS_sigret      24
+#define SYS_kthread_create 25
+#define SYS_kthread_id 26
+#define SYS_kthread_exit 27
+#define SYS_kthread_join 28
+#define SYS_bsem_alloc 29
+#define SYS_bsem_free 30
+#define SYS_bsem_down 31
+#define SYS_bsem_up 32
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..16d68bf 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -77,10 +77,13 @@ uint64
 sys_kill(void)
 {
   int pid;
+  int signum;
 
   if(argint(0, &pid) < 0)
     return -1;
-  return kill(pid);
+  if(argint(1, &signum) < 0)
+    return -1;
+  return kill(pid, signum);
 }
 
 // return how many clock tick interrupts have occurred
@@ -95,3 +98,104 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_sigprocmask(void)
+{
+  uint sigmask;
+  argaddr(0, (uint64*)&sigmask);
+  return sigprocmask(sigmask);
+}
+
+uint64
+sys_sigaction(void)
+{
+  int signum;
+  uint64 act;
+  uint64 oldact;
+  if(argint(0, &signum) < 0)
+    return -1;
+  argaddr(1, &act);
+  argaddr(2, &oldact);
+  return sigaction(signum, act, oldact);
+}
+
+uint64
+sys_sigret(void)
+{
+  sigret();
+  return 0;
+}
+
+uint64
+sys_kthread_create(void)
+{
+  uint64 func;
+  uint64 stack;
+  argaddr(0, &func);
+  argaddr(1, &stack);
+  return kthread_create(func, stack);
+}
+
+uint64
+sys_kthread_id(void)
+{
+  return kthread_id();
+}
+
+uint64
+sys_kthread_exit(void)
+{
+  int status;
+  if(argint(0, &status) < 0)
+    return -1;
+  kthread_exit(status);
+  return 0;
+}
+
+uint64
+sys_kthread_join(void)
+{
+  int tid;
+  int *status;
+  if(argint(0, &tid) < 0)
+    return -1;
+  argaddr(1, (uint64 *)&status);
+  return kthread_join(tid, status);
+}
+
+uint64
+sys_bsem_alloc(void)
+{
+  return bsem_alloc();
+}
+
+uint64
+sys_bsem_free(void)
+{
+  int d;
+  if(argint(0, &d) < 0)
+    return -1;
+  bsem_free(d);
+  return 0;
+}
+
+uint64
+sys_bsem_down(void)
+{
+  int d;
+  if(argint(0, &d) < 0)
+    return -1;
+  bsem_down(d);
+  return 0;
+}
+
+uint64
+sys_bsem_up(void)
+{
+  int d;
+  if(argint(0, &d) < 0)
+    return -1;
+  bsem_up(d);
+  return 0;
+}
\ No newline at end of file
diff --git a/kernel/trampoline.S b/kernel/trampoline.S
index fabaaf9..ea8ec8d 100644
--- a/kernel/trampoline.S
+++ b/kernel/trampoline.S
@@ -139,3 +139,11 @@ userret:
         # return to user mode and user pc.
         # usertrapret() set up sstatus and sepc.
         sret
+
+.globl sigret_start
+.globl sigret_end
+
+sigret_start:
+        li a7, 24 
+        ecall
+sigret_end:
\ No newline at end of file
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..d7d1afa 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -46,9 +46,10 @@ usertrap(void)
   w_stvec((uint64)kernelvec);
 
   struct proc *p = myproc();
+  struct thread *t = mythread();
   
   // save user program counter.
-  p->trapframe->epc = r_sepc();
+  t->trapframe->epc = r_sepc();
   
   if(r_scause() == 8){
     // system call
@@ -56,9 +57,12 @@ usertrap(void)
     if(p->killed)
       exit(-1);
 
+    if(t->killed)
+      kthread_exit(-1);
+
     // sepc points to the ecall instruction,
     // but we want to return to the next instruction.
-    p->trapframe->epc += 4;
+    t->trapframe->epc += 4;
 
     // an interrupt will change sstatus &c registers,
     // so don't enable until done with those registers.
@@ -76,6 +80,9 @@ usertrap(void)
   if(p->killed)
     exit(-1);
 
+  if(t->killed)
+      kthread_exit(-1);
+
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2)
     yield();
@@ -90,21 +97,24 @@ void
 usertrapret(void)
 {
   struct proc *p = myproc();
+  struct thread *t = mythread();
 
   // we're about to switch the destination of traps from
   // kerneltrap() to usertrap(), so turn off interrupts until
   // we're back in user space, where usertrap() is correct.
   intr_off();
 
+  handleSignals();
+
   // send syscalls, interrupts, and exceptions to trampoline.S
   w_stvec(TRAMPOLINE + (uservec - trampoline));
 
   // set up trapframe values that uservec will need when
   // the process next re-enters the kernel.
-  p->trapframe->kernel_satp = r_satp();         // kernel page table
-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
-  p->trapframe->kernel_trap = (uint64)usertrap;
-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+  t->trapframe->kernel_satp = r_satp();         // kernel page table
+  t->trapframe->kernel_sp = (uint64)t->kstack + PGSIZE; // process's kernel stack
+  t->trapframe->kernel_trap = (uint64)usertrap;
+  t->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
 
   // set up the registers that trampoline.S's sret will use
   // to get to user space.
@@ -116,7 +126,7 @@ usertrapret(void)
   w_sstatus(x);
 
   // set S Exception Program Counter to the saved user pc.
-  w_sepc(p->trapframe->epc);
+  w_sepc(t->trapframe->epc);
 
   // tell trampoline.S the user page table to switch to.
   uint64 satp = MAKE_SATP(p->pagetable);
@@ -125,7 +135,7 @@ usertrapret(void)
   // switches to the user page table, restores user registers,
   // and switches to user mode with sret.
   uint64 fn = TRAMPOLINE + (userret - trampoline);
-  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
+  ((void (*)(uint64,uint64))fn)(TRAPFRAME(t->index), satp);
 }
 
 // interrupts and exceptions from kernel code go here via kernelvec,
@@ -150,7 +160,7 @@ kerneltrap()
   }
 
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+  if(which_dev == 2 && mythread() != 0 && mythread()->state == TRUNNING)
     yield();
 
   // the yield() may have caused some traps to occur,
diff --git a/user/Csemaphore.c b/user/Csemaphore.c
new file mode 100644
index 0000000..cfda11f
--- /dev/null
+++ b/user/Csemaphore.c
@@ -0,0 +1,37 @@
+#include "Csemaphore.h"
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+
+void csem_down(struct counting_semaphore *sem) {
+    bsem_down(sem->sema_2);
+    bsem_down(sem->sema_1);
+    sem->val--;
+    if (sem->val > 0)
+        bsem_up(sem->sema_2);
+    bsem_up(sem->sema_1);
+}
+
+void csem_up(struct counting_semaphore *sem) {
+
+    bsem_down(sem->sema_1);
+    sem->val++;
+    if(sem->val == 1) 
+        bsem_up(sem->sema_2);
+    bsem_up(sem->sema_1);
+}
+
+int csem_alloc(struct counting_semaphore *sem, int initial_value){
+    if((initial_value >= 0) && ((sem->sema_1 = bsem_alloc()) >= 0) && ((sem->sema_2 = bsem_alloc()) >= 0)){
+        if(initial_value == 0)
+            bsem_down(sem->sema_2);
+        sem->val = initial_value;
+        return 0;
+    }
+    return -1; // There are no enough binary semaphores which is available  
+}
+
+void csem_free(struct counting_semaphore *sem) {
+    bsem_free(sem->sema_1);
+    bsem_free(sem->sema_2);
+}
\ No newline at end of file
diff --git a/user/Csemaphore.h b/user/Csemaphore.h
new file mode 100644
index 0000000..70e9f28
--- /dev/null
+++ b/user/Csemaphore.h
@@ -0,0 +1,10 @@
+struct counting_semaphore {
+    int val;
+    int sema_1;
+    int sema_2;
+};
+
+void csem_down(struct counting_semaphore *sem);
+void csem_up(struct counting_semaphore *sem);
+int csem_alloc(struct counting_semaphore *sem, int initial_value);
+void csem_free(struct counting_semaphore *sem);
\ No newline at end of file
diff --git a/user/grind.c b/user/grind.c
index 5cd89f4..bbf3997 100644
--- a/user/grind.c
+++ b/user/grind.c
@@ -142,12 +142,12 @@ go(int which_child)
         printf("grind: chdir failed\n");
         exit(1);
       }
-      kill(pid);
+      kill(pid, SIGKILL);
       wait(0);
     } else if(what == 18){
       int pid = fork();
       if(pid == 0){
-        kill(getpid());
+        kill(getpid(), SIGKILL);
         exit(0);
       } else if(pid < 0){
         printf("grind: fork failed\n");
@@ -324,8 +324,8 @@ iter()
   int st1 = -1;
   wait(&st1);
   if(st1 != 0){
-    kill(pid1);
-    kill(pid2);
+    kill(pid1, SIGKILL);
+    kill(pid2, SIGKILL);
   }
   int st2 = -1;
   wait(&st2);
diff --git a/user/kill.c b/user/kill.c
index 1b0253b..e4917dc 100644
--- a/user/kill.c
+++ b/user/kill.c
@@ -5,13 +5,11 @@
 int
 main(int argc, char **argv)
 {
-  int i;
-
   if(argc < 2){
     fprintf(2, "usage: kill pid...\n");
     exit(1);
   }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
+  for(int i = 1; i < argc - 1; i += 2)
+    kill(atoi(argv[i]), atoi(argv[i+1]));
   exit(0);
 }
diff --git a/user/part2Tests.c b/user/part2Tests.c
new file mode 100644
index 0000000..ba69bb4
--- /dev/null
+++ b/user/part2Tests.c
@@ -0,0 +1,150 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+
+struct sigaction {
+  void (*sa_handler) (int);
+  uint sigmask;
+};
+
+void test_handler(){
+    printf("Handling here - chaning signal handler workd!\n");
+}
+
+void init(){
+    return;
+}
+
+// Unusual cases were checked here
+int
+test_sigaction_1()
+{
+    int isOk = 1;
+    struct sigaction *act = malloc(sizeof(struct sigaction*));
+    if(sigaction(-1, act, 0) != -1){
+        printf("test1 failed - signum must be in range 0 -> 31\n");
+        isOk = 0;
+    }
+    if(sigaction(32, act, 0) != -1){
+        printf("test1 failed - signum must be in range 0 -> 31\n");
+        isOk = 0;
+    }
+    if(sigaction(SIGSTOP, act, 0) != -1){
+        printf("test1 failed - SIGSTOP was found\n");
+        isOk = 0;
+    }
+    if(sigaction(SIGKILL, act, 0) != -1){
+        printf("test1 failed - SIGKILL was found\n");
+        isOk = 0;
+    }
+    act->sigmask = (1 << SIGKILL);
+    if(sigaction(1, act, 0) == -1){
+        act->sigmask = (1 << SIGSTOP);
+        if(sigaction(1, act, 0) != -1){
+            isOk = 0;
+            printf("test1 faild - the act sigmask is SIGSTOP\n");
+        }
+    } else {
+        isOk = 0;
+        printf("test1 faild - the act sigmask is SIGKILL\n");
+    }
+    return isOk; 
+}
+
+// Mask update is checked here
+int
+test_sigaction_2()
+{
+    int isOK = 1;
+    struct sigaction *act = malloc(sizeof(struct sigaction*));
+    struct sigaction *temp = malloc(sizeof(struct sigaction*));
+    act->sa_handler = &test_handler;
+    act->sigmask = 1;
+    if(sigaction(1, act, 0) == -1){
+        isOK = 0;
+        printf("test2 failed - sigaction system call\n");
+    }
+    sigaction(1, 0, temp);
+    if(temp->sigmask != 1){
+        isOK = 0;
+        printf("test2 failed - the sigmask didn't changed successfully\n");
+    }
+    return isOK;
+}
+
+// Changing handler and using kill syscall
+int
+test_changeHandler_3()
+{
+    printf("", &init);
+    int isOK = 1;
+    struct sigaction *act = malloc(sizeof(struct sigaction*));
+    act->sa_handler = &test_handler;
+    act->sigmask = 0;
+    if(sigaction(1, act, 0) == -1){
+        isOK = 0;
+        printf("test3 failed - error in sigaction\n");
+    }
+    int pid = fork();
+    if(pid == 0){
+        kill(getpid(), 1);
+        exit(0);
+    } else {
+        wait(0);
+    }
+    return isOK;
+}
+
+// sigprocmask was checked
+int
+test_sigprocmask_4()
+{
+    int isOk = 1;
+    uint prev;
+    prev = 0;
+    uint mask1 = sigprocmask((1 << 2)); // by default it will be zero
+    if(mask1 != prev){
+        printf("test4 failed - return value of sigprocmask is invalid\n");
+        isOk = 0;
+    }
+    prev = (1 << 2);
+    uint mask2 = sigprocmask((1 << 3));
+    if(mask2 != prev){
+        printf("test4 failed - return value of sigprocmask is invalid\n");
+        isOk = 0;
+    }
+    return isOk;
+}
+
+int main(int argc, char**argv)
+{
+    int status1 = test_sigaction_1();
+    if(status1)
+        printf("sigaction unusual cases checked - OK\n");
+    else
+        printf("sigaction unusual cases checked - FAILED\n");
+    int status2 = test_sigaction_2();
+    if(status2)
+        printf("mask update cases checked - OK\n");
+    else
+        printf("mask update cases checked - FAILED\n");
+    int status3 = test_changeHandler_3();
+    if(status3)
+        printf("changing default handler checked - OK\n");
+    else
+        printf("changing default handler checked - FAILED\n");
+    int status4 = test_sigprocmask_4();
+    if(status4)
+        printf("sigprocmask checked - OK\n");
+    else
+        printf("sigprocmask checked - FAILED\n");
+    if(status1 && status2 && status3 && status4)
+        printf("ALL TESTS PASSED!\n");
+    exit(0);
+}
diff --git a/user/user.h b/user/user.h
index b71ecda..1886cc8 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,6 @@
 struct stat;
 struct rtcdate;
+struct sigaction;
 
 // system calls
 int fork(void);
@@ -9,7 +10,7 @@ int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
 int close(int);
-int kill(int);
+int kill(int, int);
 int exec(char*, char**);
 int open(const char*, int);
 int mknod(const char*, short, short);
@@ -23,6 +24,17 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int sigprocmask(uint);
+int sigaction (int, const struct sigaction*, struct sigaction*);
+void sigret(void);
+int kthread_create (void (*)(), void *);
+int kthread_id(void);
+void kthread_exit(int);
+int kthread_join(int, int*);
+int bsem_alloc(void);
+void bsem_free(int);
+void bsem_down(int);
+void bsem_up(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usertests.c b/user/usertests.c
index ba4255b..3785e3c 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -799,7 +799,7 @@ killstatus(char *s)
       exit(0);
     }
     sleep(1);
-    kill(pid1);
+    kill(pid1, SIGKILL);
     wait(&xst);
     if(xst != -1) {
        printf("%s: status should be -1\n", s);
@@ -856,9 +856,9 @@ preempt(char *s)
   }
   close(pfds[0]);
   printf("kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
+  kill(pid1, SIGKILL);
+  kill(pid2, SIGKILL);
+  kill(pid3, SIGKILL);
   printf("wait... ");
   wait(0);
   wait(0);
@@ -914,7 +914,7 @@ reparent(char *s)
     } else {
       int pid2 = fork();
       if(pid2 < 0){
-        kill(master_pid);
+        kill(master_pid, SIGKILL);
         exit(1);
       }
       exit(0);
@@ -2263,7 +2263,7 @@ sbrkfail(char *s)
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if(pids[i] == -1)
       continue;
-    kill(pids[i]);
+    kill(pids[i], SIGKILL);
     wait(0);
   }
   if(c == (char*)0xffffffffffffffffL){
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..ca3a46a 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,14 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("sigprocmask");
+entry("sigaction");
+entry("sigret");
+entry("kthread_create");
+entry("kthread_id"); 
+entry("kthread_exit"); 
+entry("kthread_join"); 
+entry("bsem_alloc");
+entry("bsem_free");
+entry("bsem_down");
+entry("bsem_up");
\ No newline at end of file
